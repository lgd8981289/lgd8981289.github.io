<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="欢迎访问我的博客，如果大家想要了解我可以访问http://chat.lgdsunday.club/，这里提供了一个好玩的交互式问题界面"><title>深入Vue实现原理，实现一个响应式框架 | LGD_Sunday</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://s13.cnzz.com/z_stat.php?id=1274342622&amp;web_id=1274342622"></script><script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1274342622'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274342622' type='text/javascript'%3E%3C/script%3E"));
$(function(){$("a[title='站长统计']").css("display","none");});</script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入Vue实现原理，实现一个响应式框架</h1><a id="logo" href="/.">LGD_Sunday</a><p class="description">济南小哥</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="http://www.lgdsunday.club/"><i class="fa fa-user"> 关于我</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入Vue实现原理，实现一个响应式框架</h1><div class="post-meta">Aug 30, 2018<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a><a href="/categories/JavaScript/Vue/">Vue</a></span></div><a class="disqus-comment-count" href="/2018/08/30/深入Vue实现原理，实现一个响应式框架/#vcomment"><span class="valine-comment-count" data-xid="/2018/08/30/深入Vue实现原理，实现一个响应式框架/"></span><span> 条评论</span></a><div class="post-content"><p>在前面的章节中我们已经学习了<code>Vue.js</code>的基础内容并且了解了<code>Vue.js</code>的源码实现，包括：<strong>Vue的生命周期、Vue的数据响应、Vue的渲染流程等等，</strong>在这一章节我们会和大家一起去实现一个<strong>响应式的框架 – <code>MVue</code>，<code>MVue</code></strong> 会遵循<code>Vue</code>的代码逻辑和实现思路，我们希望能够借助<code>MVue</code>来让大家更好的理解整个<code>Vue</code>的核心思想：<strong>响应式数据渲染。</strong></p>
<p>在开始我们的<code>MVue</code>开发之前，我们需要先了解一些必备的知识。首先是<code>Object.defineProperty(obj, prop, descriptor)</code>，这个方法可以用来定义<strong>对象的属性描述符</strong>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">我们可以点击这里来查看这个方法的详细定义</a>。我们这里主要使用到的是<code>get、set</code>描述符，我们可以使用<code>get、set</code>来监听对象的属性<code>setter、getter</code>的调用事件。我们看一下下面的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;input-msg&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;output-msg&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        msg: &apos;hello&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var key = &apos;msg&apos;;</span><br><span class="line">    </span><br><span class="line">    var val = obj[key];</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            val = newValue;</span><br><span class="line">            console.log(&apos;setter&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: function () &#123;</span><br><span class="line">            console.log(&apos;getter&apos;);</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们利用<code>Object.defineProperty</code>监听了<code>obj.msg</code>的<code>setter、getter</code>事件。所有当我们在控制台去调用<code>obj.msg</code>的时候就会调用<code>console.log(&#39;getter&#39;);</code>，当我们调用<code>obj.msg = &#39;123&#39;</code> 的时候就会调用<code>console.log(&#39;setter&#39;);</code>，由此我们就成功的监听了<code>obj.msg</code>的数据变化。那么这有什么意义呢？我们可以利用这个功能来做些什么呢？我们看一下下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;input-msg&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;output-msg&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var inputMsg = document.getElementById(&apos;input-msg&apos;),</span><br><span class="line">        outputMsg = document.getElementById(&apos;output-msg&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var obj = &#123;</span><br><span class="line">        msg: &apos;hello&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var key = &apos;msg&apos;;</span><br><span class="line">    </span><br><span class="line">    var val = obj[key];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            val = newValue;</span><br><span class="line"></span><br><span class="line">            outputMsg.innerText = obj[key];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: function () &#123;</span><br><span class="line">            console.log(&apos;getter&apos;);</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    inputMsg.addEventListener(&apos;input&apos;, function (event) &#123;</span><br><span class="line">        var newVal = event.target.value;</span><br><span class="line">        obj[key] = newVal;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们通过监听<code>input</code>的<code>input事件</code>来去改变<code>obj[key]</code>的值，使<code>obj[key]</code>的值始终等于用户输入的值，当<code>obj[key]</code>的值因为用户的输入而发生了改变的时候，会激活<code>Object.defineProperty</code>中的<code>setter</code>事件，然后我们获取到最新的<code>obj[key]</code>的值并把它赋值给<code>outputMsg</code>。这样当我们在<code>input</code>中进行输入的时候，<code>&lt;p&gt;</code>中的值也会跟随我们的输入变化。这种通过<code>Object.defineProperty</code>来监听数据变化的方式就是<code>Vue</code>中<strong>数据响应</strong>的核心思想。</p>
<p>其次大家需要了解的就是<strong>观察者模式，</strong><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">大家可以点击这里来查看<strong>观察者模式</strong>的详细解释</a>，相信这里会比我解释的更加清楚。</p>
<p>当大家了解完<strong>观察者模式</strong>之后我们就可以正式开始我们的<code>MVue</code>的开发工作。</p>
<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>整个框架的思路被分成三大块。</p>
<p>首先就是<strong>视图渲染，</strong>我们在<code>html</code>或者<code>&lt;template&gt;&lt;/template&gt;</code>中进行<code>html</code>内容编写的时候，往往是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&apos;msg&apos;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>其中的<code>v-model=&#39;msg&#39;</code> 和 <code></code> 浏览器是无法解析的，那么我们就需要把 <strong>浏览器不认识的内容转化为浏览器可以解析的内容</strong>，在<code>Vue</code>中，<code>Vue</code>通过<strong>虚拟DOM（<code>VNode</code>）</strong>描述真实<code>DOM</code>，然后通过<code>_update</code>来进行具体渲染。我们这里不去描述这个<code>VNode</code>直接通过<code>_update</code>方法来对<code>DOM</code>进行渲染操作，这个动作是发生在<code>Compile</code>中。<code>Compile</code>会解析我们的具体指令，并重新渲染<code>DOM</code>。</p>
<p>其次是监听我们的数据变化，在最初的例子中我们已经知道我们可以通过<code>Object.defineProperty(obj, prop, descriptor)</code>来实现数据的监听，那么就需要一个<code>Observer</code>类来进行<strong>数据劫持</strong>的工作，这时<code>Observer</code>承担的就是<strong>发布者的工作</strong>。当我们通过<code>Observer</code>来监听到数据变化之后，我们需要通知我们的<strong>观察者</strong>，但是对于我们的<strong>发布者</strong>来说，它并不知道谁是这个<strong>观察者</strong>，这个<strong>观察者</strong>是一个还是多个？所以这个时候，就需要有一个人来负责去收集这些依赖的工作，这个人就是<code>Dep（Dependency）</code>，我们通过<code>Dep</code>来去通知<strong>观察者<code>Watcher</code></strong>，<code>Watcher</code>订阅<code>Dep</code>，<code>Dep</code>持有<code>Watcher</code>，两者互相依赖形成一个<strong>消息中转站。</strong>当<code>Watcher</code>接收到消息，需要更改视图的时候，那么就会发布具体的消息根据<strong>具体指令的不同（<code>Directive</code>）</strong>来执行具体的操作<code>Patch</code>。这就是我们的整个<strong>从监听到渲染</strong>的过程，如下图：</p>
<p><img src="https://images.gitbook.cn/b18e9310-9ecf-11e8-a6a0-87ed492d3924" alt="这里写图片描述"></p>
<p>最后我们需要把所有的东西整合起来形成一个入口函数，输出给用户方便用户进行调用，就好像<code>Vue</code>中的<code>new Vue({})</code>操作，这里我们叫它<code>MVue</code>。</p>
<p>综合以上的内容，我们需要完成的代码内容包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── compile.js	渲染DOM，解析指令</span><br><span class="line">├── dep.js	收集依赖</span><br><span class="line">├── directive.js	所有支持到的指令</span><br><span class="line">├── mvue.js	入口函数</span><br><span class="line">├── observer.js	数据劫持</span><br><span class="line">├── patch.js	根据具体的指令来修改渲染的内容</span><br><span class="line">└── watcher.js	观察者。订阅Dep，发布消息</span><br></pre></td></tr></table></figure>
<p>我们预期的完成效果应该是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&apos;msg&apos;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new MVue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &apos;hello&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>首先我们需要先生成<code>MVue</code>的入口函数，我们仿照<code>Vue</code>的写法，创建一个<code>MVue</code>的类，并获取传入的<code>options</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function MVue (options) &#123;</span><br><span class="line">    this.$options = options;</span><br><span class="line">    this._data = options.data || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVue.prototype = &#123;</span><br><span class="line">    _getVal: function (exp) &#123;</span><br><span class="line">        return this._data[exp];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    _setVal: function (exp, newVal) &#123;</span><br><span class="line">        this._data[exp] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们实现一个<code>MVue</code>的构造函数，并为它提供了两个私有的原型方法<code>_getVal</code>和<code>_setVal</code>用于获取和设置<code>data</code>中对应<code>key</code>的值。这时我们就可以通过下面的代码来创建对应的<code>MVue</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new MVue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &apos;hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在<code>MVue</code>的构造函数之中去进行我们的 <strong>视图渲染</strong> 和 <strong>数据监听</strong> 的操作。</p>
<h2 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h2><p>然后我们进行我们的<strong>视图渲染</strong>，我们再来回顾一下我们需要解析的视图结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&apos;msg&apos;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在这段<code>html</code>之中<code>v-model</code>和<code></code>是我们<code>MVue</code>中的自定义指令，这些指令我们的浏览器是无法解析的，所以需要我们把这些指令解析为浏览器可以解析的<code>html</code>代码。以<code>&lt;p&gt;&lt;/p&gt;</code>为例，当我们声明<code>data: {msg: &#39;hello&#39;}</code>的时候，应解析为<code>&lt;p&gt;hello&lt;/p&gt;</code>。</p>
<p>我们的模板解析的操作是通过<code>compile.js</code>来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function Compile (vm, el) &#123;</span><br><span class="line">    this.$vm = vm;</span><br><span class="line">    el = this.$el = this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line"></span><br><span class="line">    if (!el) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._update(el);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Vue中使用vm._render先根据真实DOM创建了虚拟DOM，然后在vm._update把虚拟DOM转化为真实DOM并渲染,</span><br><span class="line">     * 我们这里没有虚拟DOM，所以直接通过createElm方法创建一个fragment用以渲染</span><br><span class="line">     */</span><br><span class="line">    _update: function (el) &#123;</span><br><span class="line">        this.$fragment = document.createDocumentFragment();</span><br><span class="line">        // 复制el的内容到创建的fragment</span><br><span class="line">        this.createElm(el);</span><br><span class="line">        // 把解析之后的fragment放入el中，此时fragment中的所有指令已经被解析为具体数据</span><br><span class="line">        el.appendChild(this.$fragment);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建新的DOM 用来替换 原DOM</span><br><span class="line">     */</span><br><span class="line">    createElm: function (node) &#123;</span><br><span class="line">        var childNode = node.firstChild;</span><br><span class="line">        if (childNode) &#123;</span><br><span class="line">            this.$fragment.appendChild(childNode);</span><br><span class="line">            this.createElm(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们声明了一个<code>Compile</code>的构造方法，并调用了它的<code>_update</code>原型函数，在<code>_update</code>中我们声明了一个<code>fragment</code>用于承载解析之后的模板内容，通过<code>createElm</code>的递归调用获取<code>el</code>中的元素，并把获取出的元素放入<code>fragment</code>中，最后把<code>fragment</code>添加到<code>el</code>里面。至此我们已经成功的获取到了<code>el</code>中的元素，并把这些元素重新规制。</p>
<p>接下来我们就需要对获取出来的元素进行解析操作，其实就是对<code>v-model</code>和<code></code>等指令进行解析，这个解析的时机应该在 <strong>遍历出所有的元素之后，添加<code>fragment</code>到<code>el</code>之前。</strong>我们看一下解析<code>DOM</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">	_update: function (el) &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    // 解析被创建完成的fragment，此时fragment已经拥有了el内所有的元素</span><br><span class="line">	    this.compileElm();</span><br><span class="line">	    ...</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">	/**</span><br><span class="line">	 * 对DOM进行解析</span><br><span class="line">	 */</span><br><span class="line">	compileElm: function (childNodes) &#123;</span><br><span class="line">	    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">	    if (!childNodes) &#123;</span><br><span class="line">	        childNodes = this.$fragment.childNodes;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    [].slice.call(childNodes).forEach(node =&gt; &#123;</span><br><span class="line">	        if (node.childNodes.length &gt; 0) &#123;</span><br><span class="line">	            // 迭代所有的节点</span><br><span class="line">	            this.compileElm(node.childNodes);</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        // 获取elementNode节点</span><br><span class="line">	        if (this.isElementNode(node)) &#123;</span><br><span class="line">	            if (reg.test(node.textContent)) &#123;</span><br><span class="line">	                // 匹配 &#123;&#123;*&#125;&#125;</span><br><span class="line">	                this.compileTextNode(node, RegExp.$1);</span><br><span class="line">	            &#125; </span><br><span class="line">	            // 匹配elementNode</span><br><span class="line">	            this.compileElmNode(node);</span><br><span class="line">	            </span><br><span class="line">	        &#125; </span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 解析elementNode，获取elm的所有属性然后便利，检查属性是否属于已经注册的指令,</span><br><span class="line">	 * 如果不是我们的自定义指令，那么就不需要去处理它了</span><br><span class="line">	 * 如果是已注册的指令，我们就交给directive去处理。（演示只有一个v-model）</span><br><span class="line">	 */</span><br><span class="line">	compileElmNode: function (node) &#123;</span><br><span class="line">	    var attrs = [].slice.call(node.attributes),</span><br><span class="line">	        $this = this;</span><br><span class="line">	</span><br><span class="line">	    attrs.forEach(function (attr) &#123;</span><br><span class="line">	        if (!$this.isDirective(attr.nodeName)) &#123;</span><br><span class="line">	            return;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        var exp = attr.value;</span><br><span class="line">	        // 匹配v-model指令</span><br><span class="line">	        directives.model($this.$vm, node, exp);</span><br><span class="line">	        // 去掉自定义指令</span><br><span class="line">	        node.removeAttribute(attr.name);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 解析&#123;&#123;*&#125;&#125;</span><br><span class="line">	 */</span><br><span class="line">	compileTextNode: function (node, exp) &#123;</span><br><span class="line">	    directives.text(this.$vm, node, exp);</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 判断是否是已注册的指令，这里就判断是否包含 v-</span><br><span class="line">	 */</span><br><span class="line">	isDirective: function (attrNodeName) &#123;</span><br><span class="line">	    return attrNodeName.indexOf(&apos;v-&apos;) === 0;</span><br><span class="line">	&#125;,</span><br><span class="line">	/**</span><br><span class="line">	 * 判断elmNode节点</span><br><span class="line">	 */</span><br><span class="line">	isElementNode: function (node) &#123;</span><br><span class="line">	    return node.nodeType === 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出，解析的操作主要在<code>compileElm</code>方法中进行，这个方法首先获取到<code>fragment</code>的<code>childNodes</code>，然后对<code>childNodes</code>进行了<code>forEach</code>操作，如果其中的<code>node</code>还有子节点的话，则会再次调用<code>compileElm</code>方法，然后解析这个<code>node</code>，如果是一个<code>ElementNode</code>节点，则再去判断是否为<code></code>双大括号结构，如果是则会执行<code>compileTextNode</code>来解析<code></code>，然后通过<code>compileElmNode</code>来解析<code>ElmNode</code>中的指令。</p>
<p><code>compileTextNode</code>中的实现比较简单，主要是调用了<code>directives.text(vm, node, exp)</code>进行解析，这里我们稍后再看，我们先主要来看下<code>compileElmNode</code>做了什么。</p>
<p><code>compileElmNode</code>首先把<code>node</code>中所有的属性转成了数组并拷贝给了<code>attrs</code>，然后对<code>attrs</code>进行遍历获取其中的<code>指令</code>，因为我们目前只有一个<code>v-model</code>指令，所以我们不需要在对指令进行判断，可以直接调用<code>directives.model(vm, node, exp)</code>来进行<code>v-model</code>的指令解析，最后在<code>DOM</code>中删除我们的自定义指令。</p>
<p>至此我们就复制了<code>el</code>的所有元素，并根据不同的指令把它们交由<code>directives</code>中对应的指令解析方法进行解析，这就是我们<code>compile.js</code>中所做的所有事情。接下来我们看一下<code>directives</code>是如何进行指令解析操作的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// directives.js</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指令集和</span><br><span class="line"> * </span><br><span class="line"> * v-model</span><br><span class="line"> */</span><br><span class="line">var directives = &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 链接patch方法，将指令转化为真实的数据并展示</span><br><span class="line">     */</span><br><span class="line">    _link: function (vm, node, exp, dir) &#123;</span><br><span class="line">        var patchFn = patch(vm, node, exp, dir);</span><br><span class="line">        patchFn  &amp;&amp; patchFn(node, vm._getVal(exp));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * v-model事件处理，这里的v-model只针对了&lt;input type=&apos;text&apos;&gt; </span><br><span class="line">     */</span><br><span class="line">    model: function (vm, node, exp) &#123;</span><br><span class="line">        this._link(vm, node, exp, &apos;model&apos;);</span><br><span class="line"></span><br><span class="line">        var val = vm._getVal(exp);</span><br><span class="line">        node.addEventListener(&apos;input&apos;, function (e) &#123;</span><br><span class="line">            var newVal = e.target.value;</span><br><span class="line">            if (newVal === val) return;</span><br><span class="line">            vm._setVal(exp,newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &#123;&#123;&#125;&#125;事件处理</span><br><span class="line">     */</span><br><span class="line">    text: function (vm, node, exp) &#123;</span><br><span class="line">        this._link(vm, node, exp, &apos;text&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码我们可以看出，我们首先定义了一个<code>directives</code>变量，它包含了<code>_link、model、text</code>三个指令方法，其中<code>_link</code>为私有方法，<code>model、text</code>为公开的指令方法，关于<code>_link</code>我们最后在分析，我们先来看一下<code>model</code>。</p>
<p><code>model</code>指令方法对应的为<code>v-model</code>指令，它接受三个参数，<code>vm</code>为我们的<code>MVue</code>实例，<code>node</code>为绑定该指令的对应节点，<code>exp</code>为绑定数据的key。我们先不去管<code>this._link</code>的调用，大家先来想一下我们在<code>index.html</code>中对于<code>v-model</code>的使用，我们把<code>v-model=&#39;msg&#39;</code>绑定到了我们的<code>input</code>标签上，意为当我们在<code>input</code>上进行输入的时候<code>msg</code>始终等于我们输入的值。那么我们在<code>model</code>指令方法中所要做的事情就很明确了，首先我们通过<code>vm._getVal(exp);</code>获取到<code>msg</code>当前值，然后我们监听了<code>node</code>的<code>input</code>事件，获取当前用户输入的最新值，然后通过<code>vm._setVal(exp,newVal)</code>配置到<code>vm._data</code>中，最后通过<code>val = newVal</code>重新设置<code>val</code>的值。</p>
<p>然后是<code>text</code>指令方法，这个方法直接调用了<code>this._link</code>，并且我们还记得在<code>model</code>指令方法中也调用了<code>this._link</code>，那么我们来看一下<code>_link</code>的实现。</p>
<p>在<code>_link</code>中，他接收四个参数，其中<code>dir</code>为我们的指令代码，然后它调用了一个<code>patch</code>方法，获取到了一个<code>patchFn</code>的变量，这个<code>patch</code>方法位于<code>patch.js</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// patch.js</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更改node value，在编译之前，替换 v-model  &#123;&#123;*&#125;&#125; 为真实数据</span><br><span class="line"> * @param &#123;*&#125; vm </span><br><span class="line"> * @param &#123;*&#125; node </span><br><span class="line"> * @param &#123;*&#125; exp </span><br><span class="line"> * @param &#123;*&#125; dir </span><br><span class="line"> */</span><br><span class="line">function patch (vm, node, exp, dir) &#123;</span><br><span class="line"></span><br><span class="line">    switch (dir) &#123;</span><br><span class="line">        case &apos;model&apos;:</span><br><span class="line">        /**</span><br><span class="line">         * input / textear</span><br><span class="line">         */</span><br><span class="line">        return function (node , val) &#123;</span><br><span class="line">            node.value = typeof val === &apos;undefined&apos; ? &apos;&apos; : val;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;text&apos;:</span><br><span class="line">        /**</span><br><span class="line">         * &#123;&#123;*&#125;&#125;</span><br><span class="line">         */</span><br><span class="line">        return function (node , val) &#123;</span><br><span class="line">            node.textContent = typeof val === &apos;undefined&apos; ? &apos;&apos; : val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>patch</code>的方法实现比较简单，它首先去判断了传入的指令，然后根据不同的指令返回了不同的函数。比如在<code>model</code>指令方法中，因为我们只支持<code>input、 textear</code>，所以我们接收到的<code>node</code>只会是它们两个中的一个，然后我们通过<code>node.value = val</code>来改变node中的<code>value</code>。</p>
<p>我们在<code>directives.js</code>中获取到了<code>patch</code>的返回函数<code>patchFn</code>，然后执行<code>patchFn</code>。至此我们的模板已经被解析为浏览器可以读懂的<code>html</code>代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="数据监听实现"><a href="#数据监听实现" class="headerlink" title="数据监听实现"></a>数据监听实现</h2><p>然后我们来看一下 <strong>数据监听模块的实现</strong> ，我们根据上面的 <strong>思路整理</strong> 想一下这个数据监听应该如何去实现？我们知道了我们应该在<code>observer</code>里面去实现它，但是具体应该怎么做呢？</p>
<p>再来明确一下我们的目标，我们希望 <strong>通过<code>observer</code>能够监听到我们数据<code>data</code>的变化，当我们调用<code>data.msg</code>或者<code>data.msg = &#39;123&#39;</code>的时候，会分别激活<code>getter</code>或者<code>setter</code>方法。</strong>那么我们就需要对整个<code>data</code>进行监听，当我们获取到<code>data</code>对象之后，来遍历其中的所有数据，并分别为它们添加上<code>getter</code>和<code>setter</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// observer.js</span><br><span class="line"></span><br><span class="line">function observer (value) &#123;</span><br><span class="line">    if (typeof value !== &apos;object&apos;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var ob = new Observer(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Observer (data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    this.walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    walk: function () &#123;</span><br><span class="line">        var $this = this;</span><br><span class="line">        var keys = Object.keys(this.data);</span><br><span class="line">        keys.forEach(function (key) &#123;</span><br><span class="line">            $this.defineReactive(key, $this.data[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    defineReactive: function (key, value) &#123;</span><br><span class="line">        var dep = new Dep();</span><br><span class="line">        Object.defineProperty(this.data, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true,</span><br><span class="line">            set: function (newValue) &#123;</span><br><span class="line">                if (value === newValue) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                value = newValue;</span><br><span class="line">                dep.notify();</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            get: function () &#123;</span><br><span class="line">                dep.depend();</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>observer.js</code>中我们通过<code>observer (value)</code>方法来生成<code>Observer</code>对象，其中传入的<code>value</code>为<code>data: {msg: &#39;hello&#39;}</code>。然后调用<code>Observer</code>的原型方法<code>walk</code>，遍历<code>data</code>调用<code>defineReactive</code>，通过<code>Object.defineProperty</code>为每条数据都添加上<code>setter、getter</code>监听，同时我们声明了一个<code>Dep</code>对象，这个<code>Dep</code>对象会负责<strong>收集依赖并且派发更新</strong>。大家结合我们的<strong>思路整理</strong>想一下，我们应该在什么时候去<strong>收集依赖</strong>？什么时候去<strong>派发更新</strong>？</p>
<p>当用户通过<code>input</code>进行输入修改数据的时候，我们是不是应该及时更新视图？所以在<code>setter</code>方法被激活的时候，我们应该调用<code>dep.notify()</code>方法，用于<strong>派发更新事件</strong>。</p>
<p>当我们的数据被展示出来的时候，也就是在<code>getter</code>事件被激活的时候，我们应该去<strong>收集依赖</strong>，也就是调用<code>dep.depend()</code>方法。</p>
<p>然后我们来看一下<code>Dep</code>方法的实现，在<code>Dep.js</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Dep.js</span><br><span class="line"></span><br><span class="line">var uid = 0;</span><br><span class="line">function Dep () &#123;</span><br><span class="line">    // 持有的watcher订阅者</span><br><span class="line">    this.subs = [];</span><br><span class="line">    this.id = uid++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    // 使dep与watcher互相持有</span><br><span class="line">    depend () &#123;</span><br><span class="line">        // Dep.target为watcher实例</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">            Dep.target.addDep(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 添加watcher</span><br><span class="line">    addSub: function (sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 通知所有的watcher进行更新</span><br><span class="line">    notify: function () &#123;</span><br><span class="line">        this.subs &amp;&amp; this.subs.forEach(function (sub) &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dep.js</code>的实现比较简单，它主要是就负责<strong>收集依赖（<code>watcher</code>）并且派发更新（<code>watcher.update()</code>）</strong>，我们可以看到<code>Dep</code>首先声明了<code>subs</code>用于保存订阅了<code>Dep</code>的<code>watcher</code>实例，然后给每个<code>Dep</code>实例创建了一个<code>id</code>，然后我们为<code>Dep</code>声明了三个原型方法，当调用<code>notify</code>的时候，<code>Dep</code>回去遍历所有的<code>subs</code>然后调用他的<code>update()</code>方法，当调用<code>depend</code>的时候会调用<code>watcher</code>的<code>addDep</code>方法使<code>Dep</code>与<code>Watcher</code>互相持有。其中的<code>Dep.target</code>和<code>sub</code>都为<code>Watcher</code>实例。</p>
<p>然后我们来看一下<code>Watcher.js</code>的代码实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// watcher</span><br><span class="line"></span><br><span class="line">function Watcher (vm, exp, patchFn) &#123;</span><br><span class="line">    this.depIds = &#123;&#125;;</span><br><span class="line">    this.$patchFn = patchFn;</span><br><span class="line">    this.$vm = vm;</span><br><span class="line">    this.getter = this.parsePath(exp)</span><br><span class="line">    this.value = this.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    // 更新</span><br><span class="line">    update: function () &#123;</span><br><span class="line">        this.run();</span><br><span class="line">    &#125;,</span><br><span class="line">    // 执行更新操作</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        var oldVal = this.value;</span><br><span class="line">        var newVal = this.get();</span><br><span class="line">        if (oldVal === newVal) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.$patchFn.call(this.$vm, newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 订阅Dep</span><br><span class="line">    addDep: function (dep) &#123;</span><br><span class="line">        if (this.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dep.addSub(this);</span><br><span class="line">        this.depIds[dep.id] = dep;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取exp对应值，这时会激活observer中的get事件</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        Dep.target = this;</span><br><span class="line">        var value = this.getter.call(this.$vm, this.$vm._data);</span><br><span class="line">        Dep.target = null;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 获取exp的对应值，应对a.b.c</span><br><span class="line">     */</span><br><span class="line">    parsePath: function (path) &#123;</span><br><span class="line">        var segments = path.split(&apos;.&apos;);</span><br><span class="line"></span><br><span class="line">        return function (obj) &#123;</span><br><span class="line">          for (let i = 0; i &lt; segments.length; i++) &#123;</span><br><span class="line">            if (!obj) return</span><br><span class="line">            obj = obj[segments[i]]</span><br><span class="line">          &#125;</span><br><span class="line">          return obj</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Watcher.js</code>中它直接接收了<code>patchFn</code>，大家还记得这个方法是干什么的吧？<code>patchFn</code>是更改<code>node value</code>，在编译之前，替换 <code>v-model  、 </code> 为真实数据的方法，在<code>Watcher.js</code>接收了<code>patchFn</code>，并把它赋值给<code>this.$patchFn</code>，当我们调用<code>this.$patchFn</code>的时候，就会改变我们的<code>DOM</code>渲染。</p>
<p>然后我们调用<code>parsePath</code>用于解析对象数据，并返回一个解析函数，然后把它赋值给<code>this.getter</code>。最后我们调用<code>get()</code>方法，在<code>get()</code>中我们给<code>Dep.target</code>持有了<code>Watcher</code>，并激活了一次<code>getter</code>方法，使我们在<code>observer</code>中监听的<code>getter</code>事件被激活，会调用<code>dep.depend()</code>方法，然后调用<code>watcher.addDep(dep)</code>，使<code>Dep</code>与<code>Watcher</code>互相持有，相互依赖。</p>
<p>然后我们看一下<code>update</code>方法的实现，我们知道当数据的<code>setter</code>事件被激活的时候，会调用<code>dep.notify()</code>,<code>dep.notify()</code>又会遍历所有的订阅<code>watcher</code>执行<code>update</code>方法，那么在<code>upadte</code>方法中，直接执行了<code>this.run</code>，在<code>run()</code>方法中，首先获取了 <strong>当前<code>watcher</code>所观察的<code>exp</code>的改变前值<code>oldVal</code>和修改后值<code>newVal</code></strong>，然后通过<code>patchFn</code>去修改<code>DOM</code>。</p>
<p>以上就是我们整个<strong>数据监听</strong>的流程，它首先通过<code>observer</code>来监听数据的变化，然后当数据的<code>getter</code>事件被激活的时候，调用<code>dep.depend()</code>来进行依赖收集，当数据的<code>setter</code>事件被激活的时候，调用<code>dep.notify()</code>来进行派发更新，这些的具体操作都是在我们的观察者<code>watcher</code>中完成的。</p>
<h2 id="整合MVue"><a href="#整合MVue" class="headerlink" title="整合MVue"></a>整合<code>MVue</code></h2><p>最后我们就需要把我们的 <strong>视图渲染</strong> 和 <strong>数据监听</strong> 链接起来，那么这个连接的节点应该在哪里呢？我们再来捋一下我们的流程。</p>
<p>当用户编写了我们的指令代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;inputtype=&quot;text&quot; v-model=&apos;msg&apos;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>的时候，我们通过<code>Compile</code>进行解析，当发现了我们的自定义指令<code>v-model、</code>的时候，会进行<code>directives</code>进行指令解析，其中监听的用户的输入事件，并调用了<code>vm._setVal()</code>方法，从而会激活在<code>observer</code>中定义的<code>setter</code>事件，<code>setter</code>会进行<strong>派发更新</strong>的操作，调用<code>dep.notify()</code>方法，然后便利<code>subs</code>调用<code>update</code>方法。</p>
<p>结合上面的描述，我们应该在两个地方去完成连接节点。首先是在调用<code>vm._setVal()</code>方法的时候，我们需要保证<code>observer</code>中的<code>setter</code>事件可以被激活，那么我们最好在入口函数中去声明这个<code>observer</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function MVue (options) &#123;</span><br><span class="line">    this.$options = options;</span><br><span class="line">    this._data = options.data || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    observer(this._data);</span><br><span class="line"></span><br><span class="line">    new Compile(this, this.$options.el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVue.prototype = &#123;</span><br><span class="line">    _getVal: function (exp) &#123;</span><br><span class="line">        return this._data[exp];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    _setVal: function (exp, newVal) &#123;</span><br><span class="line">        this._data[exp] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后当<code>setter</code>事件被激活之前，我们需要初始化完成<code>watcher</code>使其拥有<code>vm、exp、patchFn</code>,那么最好的时机应该在获取到<code>patchFn</code>这个返回函数的时候，所以应该在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var directives = &#123;</span><br><span class="line"></span><br><span class="line">    _bind: function (vm, exp, patchFn) &#123;</span><br><span class="line">        new Watcher(vm,exp, patchFn);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链接patch方法，将指令转化为真实的数据并展示</span><br><span class="line">     */</span><br><span class="line">    _link: function (vm, node, exp, dir) &#123;</span><br><span class="line">        var patchFn = patch(vm, node, exp, dir);</span><br><span class="line">        patchFn  &amp;&amp; patchFn(node, vm._getVal(exp));</span><br><span class="line"></span><br><span class="line">        this._bind(vm, exp, function (value) &#123;</span><br><span class="line">            patchFn  &amp;&amp; patchFn(node, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>_bind</code>方法来去初始化<code>watcher</code>。</p>
<h2 id="使用与扩展"><a href="#使用与扩展" class="headerlink" title="使用与扩展"></a>使用与扩展</h2><p>至此我们的<code>MVue</code>框架就已经被开发完成了，<a href="https://coding.net/u/LGD-Sunday/p/GitChat-Vue/git" target="_blank" rel="noopener">我们可以点击这里来获取本课程中所有的代码，</a>当我们需要使用我们的<code>MVue</code>的时候，我们可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./mvue3/patch.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./mvue3/dep.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./mvue3/directive.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./mvue3/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./mvue3/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./mvue3/compile.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=&quot;./mvue3/mvue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&apos;msg&apos;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new MVue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &apos;hello&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>因为我们的<code>MVue</code>并没有进行模块化，所以需要把所有的<code>JS</code>全部引入才能使用。大家也可以尝试一下把<code>MVue</code>进行模块化，这样就可以只通过引入<code>&lt;script src=&quot;./mvue3/mvue.js&quot;&gt;&lt;/script&gt;</code>来使用<code>MVue</code>了。</p>
<p>现在我们的<code>MVue</code>还非常的简单，大家可以想一下如何为我们的<code>MVue</code>增加更多的功能，比如说更多的指令或者添加<code>v-on:click</code>的事件处理？这里给大家留下三个问题，目的是希望大家能够亲自写一下这个项目，可能会让大家有更多的理解。</p>
<blockquote>
<p>1、实现<code>v-show</code>指令<br>2、实现<code>v-on:click</code>事件监听<br>3、如何和<code>Vue</code>一样可以直接通过<code>this.msg</code>来获取我们在<code>data</code>中定义的数据</p>
</blockquote>
<p>这三个问题的解决方案都在我们的代码中，大家可以作为参考。</p>
<p>这一章为<code>Vue.js</code>的最后一章，从下一章开始我们就会进入<code>Vue</code>周边生态的学习，希望大家一定要亲自实现一下<code>MVue</code>的代码。</p>
<hr>
<p>前端技术日新月异，每一种新的思想出现，都代表了一种技术的跃进、架构的变化，那么对于目前的前端技术而言，MVVM 的思想已经可以代表当今前端领域的前沿思想理念，Angular、React、Vue 等基于 MVVM 思想的具体实现框架，也成为了人们争相学习的一个热点。而 Vue 作为其中唯一没有大公司支持但却能与它们并驾齐驱并且隐隐有超越同类的趋势，不得不说这种增长让人感到惊奇。</p>
<p>本系列课程内容将会带领大家由浅入深的学习 Vue 的基础知识，了解 Vue 的源码设计和实现原理，和大家一起看一下尤雨溪先生的编程思想、架构设计以及如何进行代码实现。本系列课程内容主要分为三大部分：</p>
<blockquote>
<pre><code>`Vue` 的基础知识：在这一部分将学习 Vue 的基础语法及其源码的实现。例如，`Vue` 的生命周期钩子如何设计？当声明了一个 `directive` 时，`Vue` 究竟执行了什么？为什么只有通过 `vue.set` 函数才能为响应式对象添加响应式属性？如果我们自己要实现一个响应式的框架的话，应该如何下手、如何思考等。     
</code></pre><p><code>Vue</code>的周边生态：在这一部分将学习 <code>Vue</code> 的周边生态圈，包括有哪些 <code>UI</code> 库可以和 <code>Vue</code> 配合快速构建界面、如何使用 <code>vue-router</code>构建前端路由、如何使用 <code>Vuex</code> 进行状态管理、如何使用 <code>Axios</code> 进行网络请求、如何使用 <code>Webpack</code>、使用 <code>vue-cli</code> 构建出的项目里的各种配置有什么意义？<br>    项目实战：在这一部分将会通过一个有意思的自动对话系统来进行项目实战，争取通过这个小项目把学到的知识点进行一个整合。</p>
</blockquote>
<p><img src="https://images.gitbook.cn/16399d30-abf2-11e8-b976-c1b086d774ca" alt="这里写图片描述"></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/09/18/升级node.js和npm/">升级node.js和npm</a><a class="next" href="/2018/08/30/Vue的状态管理器：Vuex/">Vue的状态管理器：Vuex</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'UC5rUi67oaW2X6t3Pxukzrua-gzGzoHsz',
  appKey:'QeB4cvAyzbSXXFcYjvgwtcti',
  placeholder:'吐槽一波',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://lgdsunday.club"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AngularJS/">AngularJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/">Vue</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/Vuex/">Vuex</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript设计模式/">JavaScript设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/JavaScript设计模式详解：09、观察者模式/">JavaScript设计模式详解：09、观察者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/12/JavaScript设计模式详解：08、外观模式/">JavaScript设计模式详解：08、外观模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/12/JavaScript设计模式详解：07、代理模式/">JavaScript设计模式详解：07、代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/JavaScript设计模式详解：06、装饰器模式/">JavaScript设计模式详解：06、装饰器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/JavaScript设计模式详解：05、适配器模式/">JavaScript设计模式详解：05、适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/JavaScript设计模式详解：04、单例模式/">JavaScript设计模式详解：04、单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/JavaScript设计模式详解：03、工厂模式/">JavaScript设计模式详解：03、工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/JavaScript设计模式详解：02、UML类图/">JavaScript设计模式详解：02、UML类图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/Vue.js 3.0 新特性预览/">Vue.js 3.0 新特性预览 [转]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/JavaScript设计模式详解：01、导学/">JavaScript设计模式详解：01、导学</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 其他链接</i></div><ul></ul><a href="http://www.lgdsunday.club/" title="星期天俱乐部" target="_blank">星期天俱乐部</a><ul></ul><a href="https://blog.csdn.net/u011068996/" title="csdn" target="_blank">csdn</a><ul></ul><a href="https://juejin.im/user/5b397dbfe51d45589271b11c/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.imooc.com/u/3330348/courses?sort=publish" title="慕课网" target="_blank">慕课网</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">LGD_Sunday.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>