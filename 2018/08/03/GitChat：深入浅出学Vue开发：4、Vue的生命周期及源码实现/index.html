<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="欢迎访问我的博客，如果大家想要了解我可以访问http://chat.lgdsunday.club/，这里提供了一个好玩的交互式问题界面"><title>GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现 | LGD_Sunday</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://s13.cnzz.com/z_stat.php?id=1274342622&amp;web_id=1274342622"></script><script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1274342622'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274342622' type='text/javascript'%3E%3C/script%3E"));
$(function(){$("a[title='站长统计']").css("display","none");});</script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现</h1><a id="logo" href="/.">LGD_Sunday</a><p class="description">济南小哥</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="http://www.lgdsunday.club/"><i class="fa fa-user"> 关于我</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现</h1><div class="post-meta">Aug 3, 2018<span> | </span><span class="category"><a href="/categories/Vue/">Vue</a></span></div><a class="disqus-comment-count" href="/2018/08/03/GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现/#vcomment"><span class="valine-comment-count" data-xid="/2018/08/03/GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现/"></span><span> 条评论</span></a><div class="post-content"><p>通过上面两章的学习，我们已经学会了Vue的所有基础语法，包括：</p>
<blockquote>
<p>1、 语法<br>2、v-if、v-else、v-else-if、v-show<br>3、v-for<br>4、v-bind<br>5、v-model<br>6、v-on</p>
</blockquote>
<p>如果大家已经对这些语法牢记于心了，那么请继续往下看，如果大家对这些语法掌握的并不是很熟练的话，那么希望大家再去回顾一下前面的内容。</p>
<p>这一章我们学习<strong>Vue的生命周期</strong>，我们先来看一下<strong>Vue的生命周期</strong>的定义。</p>
<blockquote>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
</blockquote>
<p>这是Vue官网上提供的描述信息，简单来说就是：<strong>在Vue从创建实例到最终完全消亡的过程中，会执行一系列的方法，用于对应当前Vue的状态，这些方法我们叫它：生命周期钩子</strong>。我们看一下下面的生命周期图示：</p>
<p><img src="https://images.gitbook.cn/e6ef7590-83f1-11e8-aac1-63307eeea99f" alt="这里写图片描述"></p>
<p>在上面的图示中，共展示出来<strong>8个生命周期钩子函数</strong>，这8个函数就描绘出来了Vue整个的运行周期。而截止到目前的Vue版本-2.5.16。Vue的声明周期钩子总共为11个，除去刚才的8个之外，还有3个关于<strong>组件</strong>的生命周期钩子。我们看一下所有的<strong>钩子函数解释</strong>，配合上面的图示，可以更好地理解<strong>Vue的运行周期</strong>。</p>
<blockquote>
<p>1、beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。<br>2、created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。<br>3、beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。<br>4、mounted：el 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 <code>vm.$el</code> 也在文档内（PS:注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 mounted：）。<code>vm.$nextTick</code>会在后面的章节详细讲解，这里大家需要知道有这个东西。<br>5、beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<br>6、updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之（PS:计算属性与watcher会在后面的章节进行介绍）。<br>7、activated：keep-alive 组件激活时调用（PS：与组件相关，关于keep-alive会在讲解组件的时候为大家介绍）。<br>8、deactivated：keep-alive 组件停用时调用（PS：与组件相关，关于keep-alive会在讲解组件的时候为大家介绍）。<br>9、beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。<br>10、destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br>11、errorCaptured（2.5.0+ 新增）：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</blockquote>
<p>这就是Vue（2.5.16）中所有的生命周期钩子，为了更方便大家的理解，我们来看一下，在Vue的代码中，从<strong>创建</strong>到<strong>销毁</strong>是如何在实现的。<a href="https://github.com/vuejs/vue/archive/dev.zip" target="_blank" rel="noopener">大家可以点击这里来下载Vue的最新代码。</a></p>
<p>我们先大致看一下<code>Vue源代码的基础结构</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BACKERS.md </span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── benchmarks</span><br><span class="line">├── dist</span><br><span class="line">├── examples</span><br><span class="line">├── flow</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── packages</span><br><span class="line">├── scripts</span><br><span class="line">├── src</span><br><span class="line">├── test</span><br><span class="line">├── types</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>这是下载下来代码之后的一级目录，<code>dist文件夹下为Vue编译之后的代码，我们平时引入的Vue.js文件都在这里</code>，<code>Vue使用了flow作为JavaScript静态类型检查工具，相关的代码都在flow文件夹下面</code>，<code>scripts文件夹下面是代码构建的相关配置，Vue主要使用Rollup进行的代码构建</code>，<code>src文件夹下面就是所有Vue的源代码</code>。我们这里不对其他的内容进行过多的描述，还是专注于我们的主题，<strong>Vue的声明周期代码是如何实现</strong>，我们看一下<code>src</code>文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── compiler ：Vue编译相关</span><br><span class="line">├── core	：Vue的核心代码</span><br><span class="line">├── platforms	：web/weex平台支持，入口文件</span><br><span class="line">├── server	：服务端</span><br><span class="line">├── sfc	：解析.vue文件</span><br><span class="line">└── shared	：公共代码</span><br></pre></td></tr></table></figure>
<p>这是我们<code>src</code>文件夹下的目录结构，而我们<strong>Vue生成的地方就在</strong><code>/src/core/instance/index.js</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到：<strong>Vue是一个方法，是一个使用Function来实现的构造函数，所以我们只能通过 new 的方式来去创建Vue的实例。</strong>然后通过<code>Vue实例</code>的<code>_init</code>方法来进行Vue的初始化。<code>_init</code>是Vue通过<code>prototype</code>来实现的一个<code>原型属性</code>。我们来看一下他的<code>_init</code>方法实现。</p>
<p>在<code>/src/core/instance/init.js</code>文件夹下，Vue实现了<code>_init</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">	...</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line">    ...</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我主要看与它生命周期有关的代码，我们可以看到，<code>Vue先调用了initLifecycle(vm)、initEvents(vm)、initRender(vm)</code>这三个方法，用于初始化<code>生命周期、事件、渲染函数</code>，这些过程发生在<code>Vue初始化的过程(_init方法)中</code>，并在调用<code>beforeCreate钩子</code>之前。</p>
<p>然后Vue通过<code>callHook (vm: Component, hook: string)</code>方法来去调用<code>钩子函数(hook)</code>，它接收<code>vm（Vue实例对象），hook（钩子函数名称）</code>来去执行<code>生命周期函数</code>。在Vue中<strong>几乎所有的钩子（<code>errorCaptured</code>除外）函数执行都是通过<code>callHook (vm: Component, hook: string)</code>来调用的</strong>。我们来看一下<code>callHook</code>的代码，在<code>/src/core/instance/lifecycle.js</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  // #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget()</span><br><span class="line">  const handlers = vm.$options[hook]</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        handlers[i].call(vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `$&#123;hook&#125; hook`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&apos;hook:&apos; + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的逻辑也非常简单，根据传入的<code>hook</code>从实例中拿到对应的回调函数数组（在<code>/packages/vue-template-compiler/browser.js</code>下的<code>LIFECYCLE_HOOKS</code>），然后便利执行。</p>
<p>然后在初始化<code>生命周期、事件、渲染函数</code>之后调用了<code>beforeCreate钩子</code>，在这个时候：<strong>我们还没有办法获取到<code>data、props</code>等数据</strong>。</p>
<p>在调用了<code>beforeCreate钩子</code>之后，<code>Vue调用了initInjections(vm)、initState(vm)、initProvide(vm)</code>这三个方法用于初始化<code>data、props、watcher</code>等等，在这些初始化执行完成之后，调用了<code>created钩子函数</code>，在这个时候：<strong>我们已经可以获取到<code>data、props</code>等数据了，但是Vue并没有开始<code>渲染DOM</code>，所以我们还不能够访问DOM（PS：我们可以通过<code>vm.$nextTick</code>来访问，在后面的章节我们会详细讲解）。</strong></p>
<p>在调用了<code>created钩子</code>之后，<strong>Vue开始进行DOM的挂载</strong>，执行<code>vm.$mount(vm.$options.el)</code>，在Vue中DOM的挂载就是通过<code>Vue.prototype.$mount</code>这个原型方法来去实现的。<code>Vue.prototype.$mount</code>原型方法的声明是在<code>/src/platforms/web/entry-runtime-with-compiler.js</code>，我们看一下这个代码的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options = this.$options</span><br><span class="line">  // resolve template/el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template = options.template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template === &apos;string&apos;) &#123;</span><br><span class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          /* istanbul ignore if */</span><br><span class="line">          if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              `Template element not found or is empty: $&#123;options.template&#125;`,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">          warn(&apos;invalid template option:&apos; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&apos;compile&apos;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&apos;compile end&apos;)</span><br><span class="line">        measure(`vue $&#123;this._name&#125; compile`, &apos;compile&apos;, &apos;compile end&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get outerHTML of elements, taking care</span><br><span class="line"> * of SVG elements in IE as well.</span><br><span class="line"> */</span><br><span class="line">function getOuterHTML (el: Element): string &#123;</span><br><span class="line">  if (el.outerHTML) &#123;</span><br><span class="line">    return el.outerHTML</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const container = document.createElement(&apos;div&apos;)</span><br><span class="line">    container.appendChild(el.cloneNode(true))</span><br><span class="line">    return container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码的主要作用：<strong>就是进行<code>template模板的解析</code></strong>。从上面的代码中可以看出，<strong>el不允许被挂载到<code>body</code>和<code>html</code>这样的根标签上面。</strong>然后判断是否有<code>render函数 -&gt; if (!options.render) {...}</code>,然后判断有没有<code>template</code>，template可以是<strong><code>string类型的id</code>、<code>DOM节点</code></strong>。没有的话则解析<code>el</code>作为<code>template</code>。由上面的代码可以看出<strong>我们无论是使用<code>单文件组件（.Vue）</code>或是通过<code>el、template属性</code>，它最终都会通过<code>render</code>函数的形式来进行整个模板的解析</strong>。</p>
<p>由我们的图示可以看出模板解析完成之后，会调用<code>beforeMount钩子</code>，那么这个<code>beforeMount钩子</code>是在哪里被调用的呢？我们接着往下看。<code>$mount</code>原型方法有一个可复用的设计，在<code>/src/platforms/web/runtime/index.js</code>下，有这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// public mount method</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<strong>公共的挂载方法</strong>，目的是为了被<code>runtime only</code>版本的Vue直接使用，它调用了<code>mountComponent</code>方法。我们看一下<code>mountComponent</code>方法的实现，实现在<code>/src/core/instance/lifecycle.js</code>下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You are using the runtime-only build of Vue where the template &apos; +</span><br><span class="line">          &apos;compiler is not available. Either pre-compile the templates into &apos; +</span><br><span class="line">          &apos;render functions, or use the compiler-included build.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Failed to mount component: template or render function not defined.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // we set this to vm._watcher inside the watcher&apos;s constructor</span><br><span class="line">  // since the watcher&apos;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  // component&apos;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  // manually mounted instance, call mounted on self</span><br><span class="line">  // mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &apos;mounted&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出在执行<code>vm._render()</code>之前，调用了<code>callHook(vm, &#39;beforeMount&#39;)</code>，这个时候<strong>相关的 render 函数首次被调用</strong>，调用完成之后，执行了<code>callHook(vm, &#39;mounted&#39;)</code>方法，标记着<strong>el 被新创建的 vm.$el 替换，并被挂载到实例上。</strong></p>
<p>然后就进入了我们<code>页面正常交互的时间</code>，也就是<code>beforeUpdate</code>和<code>updated</code>这两个回调钩子的执行时机。这两个钩子函数是在<strong>数据更新的时候进行回调的函数</strong>，Vue在<code>/src/core/instance/lifecycle.js</code>文件下有一个<code>_update</code>的原型声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &apos;beforeUpdate&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    const prevEl = vm.$el</span><br><span class="line">    const prevVnode = vm._vnode</span><br><span class="line">    const prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    // Vue.prototype.__patch__ is injected in entry points</span><br><span class="line">    // based on the rendering backend used.</span><br><span class="line">    if (!prevVnode) &#123;</span><br><span class="line">      // initial render</span><br><span class="line">      vm.$el = vm.__patch__(</span><br><span class="line">        vm.$el, vnode, hydrating, false /* removeOnly */,</span><br><span class="line">        vm.$options._parentElm,</span><br><span class="line">        vm.$options._refElm</span><br><span class="line">      )</span><br><span class="line">      // no need for the ref nodes after initial patch</span><br><span class="line">      // this prevents keeping a detached DOM tree in memory (#5851)</span><br><span class="line">      vm.$options._parentElm = vm.$options._refElm = null</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // updates</span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance = prevActiveInstance</span><br><span class="line">    // update __vue__ reference</span><br><span class="line">    if (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = null</span><br><span class="line">    &#125;</span><br><span class="line">    if (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // if parent is an HOC, update its $el as well</span><br><span class="line">    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    // updated hook is called by the scheduler to ensure that children are</span><br><span class="line">    // updated in a parent&apos;s updated hook.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在<strong>如果<code>_isMounted</code>为<code>ture</code>的话（DOM已经被挂载）则会调用<code>callHook(vm, &#39;beforeUpdate&#39;)</code>方法</strong>，然后会对<strong>虚拟DOM进行重新渲染。</strong>然后在<code>/src/core/observer/scheduler.js</code>下的<code>flushSchedulerQueue()</code>函数中<strong>渲染DOM</strong>，在渲染完成调用<code>callHook(vm, &#39;updated&#39;)</code>，代码如下：。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Flush both queues and run the watchers.</span><br><span class="line"> */</span><br><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line"> ...</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callUpdatedHooks (queue) &#123;</span><br><span class="line">  let i = queue.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    const watcher = queue[i]</span><br><span class="line">    const vm = watcher.vm</span><br><span class="line">    if (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &apos;updated&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Vue实例需要进行销毁的时候回调<code>beforeDestroy 、destroyed</code>这两个函数钩子，它们的实现是在<code>/src/core/instance/lifecycle.js</code>下的<code>Vue.prototype.$destroy</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.prototype.$destroy = function () &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (vm._isBeingDestroyed) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeDestroy&apos;)</span><br><span class="line">  vm._isBeingDestroyed = true</span><br><span class="line">  // remove self from parent</span><br><span class="line">  const parent = vm.$parent</span><br><span class="line">  if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">    remove(parent.$children, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  // teardown watchers</span><br><span class="line">  if (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">  let i = vm._watchers.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    vm._watchers[i].teardown()</span><br><span class="line">  &#125;</span><br><span class="line">  // remove reference from data ob</span><br><span class="line">  // frozen object may not have observer.</span><br><span class="line">  if (vm._data.__ob__) &#123;</span><br><span class="line">    vm._data.__ob__.vmCount--</span><br><span class="line">  &#125;</span><br><span class="line">  // call the last hook...</span><br><span class="line">  vm._isDestroyed = true</span><br><span class="line">  // invoke destroy hooks on current rendered tree</span><br><span class="line">  vm.__patch__(vm._vnode, null)</span><br><span class="line">  // fire destroyed hook</span><br><span class="line">  callHook(vm, &apos;destroyed&apos;)</span><br><span class="line">  // turn off all instance listeners.</span><br><span class="line">  vm.$off()</span><br><span class="line">  // remove __vue__ reference</span><br><span class="line">  if (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = null</span><br><span class="line">  &#125;</span><br><span class="line">  // release circular reference (#6759)</span><br><span class="line">  if (vm.$vnode) &#123;</span><br><span class="line">    vm.$vnode.parent = null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>$destroy</code>这个原型函数中，执行了<code>Vue的销毁操作</code>，我们可以看到在执行销毁操作之前调用了<code>callHook(vm, &#39;beforeDestroy&#39;)</code>，然后执行了一系列的<strong>销毁操作，包括删除掉所有的<code>自身（self）、_watcher、数据引用</code>等等</strong>，删除完成之后调用<code>callHook(vm, &#39;destroyed&#39;)</code>。</p>
<p>截止到这里，整个<strong>Vue生命周期图示</strong>中的所有<code>生命周期钩子</code>都已经被执行完成了。那么剩下的<code>activated、deactivated、errorCaptured</code>这三个钩子函数是在何时被执行的呢？我们知道这三个函数都是针对于<code>组件（component）</code>的钩子函数。其中<code>activated、deactivated</code>这两个钩子函数分别是在<code>keep-alive 组件激活和停用</code>之后回调的，<strong>它们不牵扯到整个Vue的生命周期之中</strong>，<code>activated、deactivated</code>这两个钩子函数的实现代码都在<code>/src/core/instance/lifecycle.js</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export function activateChildComponent (vm: Component, direct?: boolean) &#123;</span><br><span class="line">  if (direct) &#123;</span><br><span class="line">    vm._directInactive = false</span><br><span class="line">    if (isInInactiveTree(vm)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (vm._directInactive) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._inactive || vm._inactive === null) &#123;</span><br><span class="line">    vm._inactive = false</span><br><span class="line">    for (let i = 0; i &lt; vm.$children.length; i++) &#123;</span><br><span class="line">      activateChildComponent(vm.$children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, &apos;activated&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deactivateChildComponent (vm: Component, direct?: boolean) &#123;</span><br><span class="line">  if (direct) &#123;</span><br><span class="line">    vm._directInactive = true</span><br><span class="line">    if (isInInactiveTree(vm)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!vm._inactive) &#123;</span><br><span class="line">    vm._inactive = true</span><br><span class="line">    for (let i = 0; i &lt; vm.$children.length; i++) &#123;</span><br><span class="line">      deactivateChildComponent(vm.$children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, &apos;deactivated&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于<code>errorCaptured</code>来说，它是在2.5.0之后新增的一个钩子函数，它的代码在<code>/src/core/util/error.js</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">export function handleError (err: Error, vm: any, info: string) &#123;</span><br><span class="line">  if (vm) &#123;</span><br><span class="line">    let cur = vm</span><br><span class="line">    while ((cur = cur.$parent)) &#123;</span><br><span class="line">      const hooks = cur.$options.errorCaptured</span><br><span class="line">      if (hooks) &#123;</span><br><span class="line">        for (let i = 0; i &lt; hooks.length; i++) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            const capture = hooks[i].call(cur, err, vm, info) === false</span><br><span class="line">            if (capture) return</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            globalHandleError(e, cur, &apos;errorCaptured hook&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  globalHandleError(err, vm, info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function globalHandleError (err, vm, info) &#123;</span><br><span class="line">  if (config.errorHandler) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return config.errorHandler.call(null, err, vm, info)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      logError(e, null, &apos;config.errorHandler&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  logError(err, vm, info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logError (err, vm, info) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    warn(`Error in $&#123;info&#125;: &quot;$&#123;err.toString()&#125;&quot;`, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  /* istanbul ignore else */</span><br><span class="line">  if ((inBrowser || inWeex) &amp;&amp; typeof console !== &apos;undefined&apos;) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他是唯一一个没有通过<code>callHook</code>方法来执行的钩子函数，而是直接通过遍历<code>cur(vm).$options.errorCaptured</code>，来执行<code>config.errorHandler.call(null, err, vm, info)</code>的钩子函数。整个逻辑的结构与<code>callHook</code>使非常类似的。</p>
<p>截止到目前Vue中所有的<strong>生命周期钩子</strong>我们都已经介绍完成了，其中涉及到了一些源码的基础，是因为我觉得配合源码来一起看的话，会对整个Vue的运行过程有个更好的理解。大家一定要<a href="https://github.com/vuejs/vue/archive/dev.zip" target="_blank" rel="noopener">下载下来Vue的源代码</a>，对照着我们的讲解来走一遍这个流程。</p>
<hr>
<p>新课程《深入浅出学Vue开发》以上线GitChat，欢迎大家购买，博客只会上传部分章节。</p>
<p><img src="http://res.lgdsunday.club/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6Vue%E5%BC%80%E5%8F%91.JPG" alt="这里写图片描述"></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/30/Vue的状态管理器：Vuex/">Vue的状态管理器：Vuex</a><a class="next" href="/2018/08/03/GitChat：深入浅出学Vue开发：1、初探Vue/">GitChat：深入浅出学Vue开发：1、初探Vue</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'UC5rUi67oaW2X6t3Pxukzrua-gzGzoHsz',
  appKey:'QeB4cvAyzbSXXFcYjvgwtcti',
  placeholder:'吐槽一波',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://lgdsunday.club"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AngularJS/">AngularJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/">Vue</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/Vuex/">Vuex</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/10/Vue 3.0 plan/">尤雨溪：Vue 3.0 计划（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/升级node.js和npm/">升级node.js和npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/深入Vue实现原理，实现一个响应式框架/">深入Vue实现原理，实现一个响应式框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/Vue的状态管理器：Vuex/">Vue的状态管理器：Vuex</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现/">GitChat：深入浅出学Vue开发：4、Vue的生命周期及源码实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/GitChat：深入浅出学Vue开发：1、初探Vue/">GitChat：深入浅出学Vue开发：1、初探Vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/GitChat：深入浅出学Vue开发：导读/">GitChat：深入浅出学Vue开发：导读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/IOS 嵌套实现分页的TableView/">IOS 嵌套实现分页的TableView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/Activity触摸事件的分发机制/">Activity触摸事件的分发机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/Android 6.0RunTime Permission完美解决方案/">Android 6.0RunTime Permission完美解决方案</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 其他链接</i></div><ul></ul><a href="http://www.lgdsunday.club/" title="星期天俱乐部" target="_blank">星期天俱乐部</a><ul></ul><a href="https://blog.csdn.net/u011068996/" title="csdn" target="_blank">csdn</a><ul></ul><a href="https://juejin.im/user/5b397dbfe51d45589271b11c/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.imooc.com/u/3330348/courses?sort=publish" title="慕课网" target="_blank">慕课网</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">LGD_Sunday.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>